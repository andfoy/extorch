/// Index a dimension using a sequence of indices (aka advanced indexing)
fn index(
    tensor: &SharedPtr<CrossTensor>,
    indices: Vec<TorchIndex>,
) -> Result<SharedPtr<CrossTensor>>;

/// Assign a value into a tensor given a sequence of indices
fn index_put(
    tensor: &SharedPtr<CrossTensor>,
    indices: Vec<TorchIndex>,
    value: &SharedPtr<CrossTensor>,
    inplace: bool,
) -> Result<SharedPtr<CrossTensor>>;

/// Add an empty dimension to a tensor at the given dimension.
fn unsqueeze(tensor: &SharedPtr<CrossTensor>, dim: i64) -> Result<SharedPtr<CrossTensor>>;

/// Rearrange a tensor into a new shape
fn reshape(tensor: &SharedPtr<CrossTensor>, shape: Vec<i64>) -> Result<SharedPtr<CrossTensor>>;

/// Returns a view of input with a flipped conjugate bit.
fn conj(input: &SharedPtr<CrossTensor>) -> Result<SharedPtr<CrossTensor>>;

/// Returns a view of the tensor conjugated and with the last two dimensions transposed.
fn adjoint(input: &SharedPtr<CrossTensor>) -> Result<SharedPtr<CrossTensor>>;

/// Transpose dimensions dim0 and dim1 in the input tensor.
fn transpose(
    input: &SharedPtr<CrossTensor>,
    dim0: i64,
    dim1: i64,
) -> Result<SharedPtr<CrossTensor>>;

/// Concatenate a sequence of tensors across a dimension.
fn cat(seq: TensorList, dim: i64, out: TensorOut) -> Result<SharedPtr<CrossTensor>>;

/// Attempt to split a tensor into a given number of chunks.
fn chunk(input: &SharedPtr<CrossTensor>, chunks: i64, dim: i64) -> Result<TensorList>;

/// Split a tensor into multiple ones in a given dimension, according to indices_or_sections.
fn tensor_split(
    input: &SharedPtr<CrossTensor>,
    indices_or_sections: TensorOrInt,
    dim: i64,
) -> Result<TensorList>;

/// Split a tensor of three or more dimensions depthwise according to indices_or_sections.
fn dsplit(input: &SharedPtr<CrossTensor>, indices_or_sections: IntListOrInt) -> Result<TensorList>;

/// Creates a new tensor by horizontally stacking a sequence of tensors.
fn column_stack(tensors: TensorList, out: TensorOut) -> Result<SharedPtr<CrossTensor>>;

/// Creates a new tensor by stacking depthwise a sequence of tensors.
fn dstack(tensors: TensorList, out: TensorOut) -> Result<SharedPtr<CrossTensor>>;

/// Gathers values along an axis specified by dim.
fn gather(
    input: &SharedPtr<CrossTensor>,
    dim: i64,
    index: &SharedPtr<CrossTensor>,
    sparse_grad: bool,
    out: TensorOut,
) -> Result<SharedPtr<CrossTensor>>;

/// Split a tensor of one or more dimensions horizontally according to indices_or_sections.
fn hsplit(input: &SharedPtr<CrossTensor>, indices_or_sections: IntListOrInt) -> Result<TensorList>;

/// Creates a new tensor by stacking horizontally a sequence of tensors.
fn hstack(tensors: TensorList, out: TensorOut) -> Result<SharedPtr<CrossTensor>>;

/// Add a source tensor values into input (times an scalar) given an index.
fn index_add(
    input: &SharedPtr<CrossTensor>,
    dim: i64,
    index: &SharedPtr<CrossTensor>,
    source: &SharedPtr<CrossTensor>,
    alpha: Scalar,
    out: TensorOut,
    inplace: bool,
) -> Result<SharedPtr<CrossTensor>>;

/// Copy a source tensor values into input given an index.
fn index_copy(
    input: &SharedPtr<CrossTensor>,
    dim: i64,
    index: &SharedPtr<CrossTensor>,
    source: &SharedPtr<CrossTensor>,
    out: TensorOut,
    inplace: bool,
) -> Result<SharedPtr<CrossTensor>>;

/// Reduce a source tensor values into input given an index and a reduction operation.
fn index_reduce(
    input: &SharedPtr<CrossTensor>,
    dim: i64,
    index: &SharedPtr<CrossTensor>,
    source: &SharedPtr<CrossTensor>,
    reduce: String,
    include_self: bool,
    out: TensorOut,
    inplace: bool,
) -> Result<SharedPtr<CrossTensor>>;

/// Index an input tensor alongside a dimension given an index tensor.
fn index_select(
    input: &SharedPtr<CrossTensor>,
    dim: i64,
    index: &SharedPtr<CrossTensor>,
    out: TensorOut,
) -> Result<SharedPtr<CrossTensor>>;

/// Index an input tensor using a boolean mask tensor.
fn masked_select(
    input: &SharedPtr<CrossTensor>,
    mask: &SharedPtr<CrossTensor>,
    out: TensorOut,
) -> Result<SharedPtr<CrossTensor>>;

/// Swap two or more dimensions to a new position.
fn movedim(
    input: &SharedPtr<CrossTensor>,
    source: Vec<i64>,
    destination: Vec<i64>,
) -> Result<SharedPtr<CrossTensor>>;

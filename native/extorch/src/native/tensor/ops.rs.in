/// Index a dimension using a sequence of indices (aka advanced indexing)
fn index(
    tensor: &SharedPtr<CrossTensor>,
    indices: Vec<TorchIndex>,
) -> Result<SharedPtr<CrossTensor>>;

/// Assign a value into a tensor given a sequence of indices
fn index_put(
    tensor: &SharedPtr<CrossTensor>,
    indices: Vec<TorchIndex>,
    value: &SharedPtr<CrossTensor>,
) -> Result<SharedPtr<CrossTensor>>;

/// Add an empty dimension to a tensor at the given dimension.
fn unsqueeze(tensor: &SharedPtr<CrossTensor>, dim: i64) -> Result<SharedPtr<CrossTensor>>;

/// Rearrange a tensor into a new shape
fn reshape(tensor: &SharedPtr<CrossTensor>, shape: Vec<i64>) -> Result<SharedPtr<CrossTensor>>;

/// Returns a view of input with a flipped conjugate bit.
fn conj(input: &SharedPtr<CrossTensor>) -> Result<SharedPtr<CrossTensor>>;

/// Returns a view of the tensor conjugated and with the last two dimensions transposed.
fn adjoint(input: &SharedPtr<CrossTensor>) -> Result<SharedPtr<CrossTensor>>;

/// Transpose dimensions dim0 and dim1 in the input tensor.
fn transpose(
    input: &SharedPtr<CrossTensor>,
    dim0: i64,
    dim1: i64,
) -> Result<SharedPtr<CrossTensor>>;

/// Concatenate a sequence of tensors across a dimension.
fn cat(seq: TensorList, dim: i64, out: TensorOut) -> Result<SharedPtr<CrossTensor>>;

/// Attempt to split a tensor into a given number of chunks.
fn chunk(input: &SharedPtr<CrossTensor>, chunks: i64, dim: i64) -> Result<TensorList>;

/// Split a tensor into multiple ones in a given dimension, according to indices_or_sections.
fn tensor_split(
    input: &SharedPtr<CrossTensor>,
    indices_or_sections: TensorOrInt,
    dim: i64,
) -> Result<TensorList>;

/// Split a tensor of three or more dimensions depthwise according to indices_or_sections.
fn dsplit(
    input: &SharedPtr<CrossTensor>,
    indices_or_sections: IntListOrInt
) -> Result<TensorList>;

/// Creates a new tensor by horizontally stacking a sequence of tensors.
fn column_stack(
    tensors: TensorList,
    out: TensorOut
) -> Result<SharedPtr<CrossTensor>>;

/// Creates a new tensor by stacking depthwise a sequence of tensors.
fn dstack(
    tensors: TensorList,
    out: TensorOut
) -> Result<SharedPtr<CrossTensor>>;
